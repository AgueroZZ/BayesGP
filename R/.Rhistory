components[[4]]
components[[4]][[1]]
components[[4]][[2]]
components[[4]][[3]]
stop("")
stop("The covariate name must be specified as smoothing_var or x.")
formula <- y~x + f(smoothing_var = d)
formula[[1]]
formula[[2]]
formula[[3]]
parse_result <- parse_formula(formula)
parse_result
parse_result$rand_effects
parse_result$rand_effects[[1]]$smoothing_var
eval
formula <- y~x + f(smoothing_var = s, sd.prior = 2)
parse_result <- parse_formula(formula)
response_var <- parse_result$response
rand_effects <- parse_result$rand_effects
fixed_effects <- parse_result$fixed_effects
rand_effect = rand_effects[[1]]
rand_effect
eval(rand_effect$sd.prior)
rand_effect$sd.prior
formula <- y~x + f(smoothing_var = s, sd.prior = list(u = 1, alpha = 2))
rand_effects <- parse_result$rand_effects
parse_result <- parse_formula(formula)
rand_effects <- parse_result$rand_effects
rand_effect = rand_effects[[1]]
sd.prior <- eval(rand_effect$sd.prior)
sd.prior
length(rand_effects)
length(sd.prior)
sd.prior2 <- list(sd.prior$u)
sd.prior2
sd.prior2 <- list(u = sd.prior$u)
sd.prior2
as.numeric(sd.prior2)
sd.prior
sd.prior <- 1
sd.prior
if (length(sd.prior) == 1){
sd.prior <- list(prior = "exp", para = list(u = as.numeric(sd.prior), alpha = 0.5))
}
sd.prior
OSplines::covid_canada
OSplines::covid_canada[["t"]]
OSplines::covid_canada
mtcars
sort(mtcars, mpg)
sort(mtcars, by = mpg)
sort(mtcars, by = "mpg")
?sort
order(mtcars, by = "mpg")
order(mtcars, by = mpg)
newdata <- mtcars[order(mpg),]
newdata <- mtcars[order(mtcars$mpg),]
newdata
dplyr::arrange(mtcars, mpg)
sGPfit::compute_d_step_sGPsd
sGPfit::Compute_B_sB
sGPfit::Compute_B_sB
sGPfit::Compute_Q_sB
sGPfit::Compute_B_sB
debugSource("~/Documents/GitHub/OSplines/R/functions.R", echo=TRUE)
debugSource("~/Documents/GitHub/OSplines/R/functions.R", echo=TRUE)
k <- eval(rand_effect$k)
?nlminb()
nlminb
get_default_option_list_MCMC <- function(option_list = list()){
default_options <- list(chains = 1, cores = 1, init = "random", seed = 123)
for (name in required_names) {
if(! name %in% names(option_list)){
option_list[[name]] <- default_options[[name]]
}
}
option_list
}
get_default_option_list_MCMC(list(chains = 2))
get_default_option_list_MCMC <- function(option_list = list()){
default_options <- list(chains = 1, cores = 1, init = "random", seed = 123)
required_names <- names(default_options)
for (name in required_names) {
if(! name %in% names(option_list)){
option_list[[name]] <- default_options[[name]]
}
}
option_list
}
get_default_option_list_MCMC(list(chains = 2))
get_default_option_list_MCMC(list(chains = 3))
get_default_option_list_MCMC(list())
get_default_option_list_MCMC
get_default_option_list_MCMC
tmbstan::d
install.packages("tmbstan")
methods(class="stanfit").
methods(class="stanfit")
devtools::document()
warnings()
devtools::document()
warnings()
example_data <- data.frame(case = c(0,1,0,0,0,1,0,0,1,0),
strata = c(1,1,1,2,2,2,3,3,3,3),
weight = c(0,1,0,0,0,5,0,0,2,0))
example_data
case_day <- which(example_data$case > 0)
case_day
example_data[case_day,]
# Initialize a list to store the control_day for each strata
control_day_list <- list()
# Loop through unique strata
for (s in unique(example_data$strata)) {
# Subset data for each strata
strata_data <- example_data[example_data$strata == s, ]
# Identify case days within the strata
case_day_strata <- which(strata_data$case > 0)
# Identify control days within the strata
control_day_strata <- which(strata_data$case == 0)
# Create matrix to store results for this strata
N <- max(length(control_day_strata), 1)  # Ensure at least one column
M <- length(case_day_strata)
control_day_matrix <- matrix(0, nrow = M, ncol = N + 1)
for (i in 1:M) {
control_day_matrix[i, 1] <- case_day_strata[i]  # Case day itself as first column
control_day_matrix[i, 2:(N + 1)] <- control_day_strata  # Fill in the control days
}
# Add the matrix to the list
control_day_list[[as.character(s)]] <- control_day_matrix
}
control_day_list
max_N <- max(sapply(unique_strata, function(s) sum(strata == s & case == 0)))
unique_strata <- unique(strata)
### we can find:
strata <- example_data$strata
case <- example_data$case
case_day <- which(case > 0)
count <- weight[case_day]
strata <- example_data$strata
case <- example_data$case
weight <- example_data$weight
case_day <- which(case > 0)
count <- weight[case_day]
count
case_day
unique_strata <- unique(strata)
control_day_list <- list()
max_N <- max(sapply(unique_strata, function(s) sum(strata == s & case == 0)))
max_N
for (s in unique_strata) {
# Get the indices for case days and control days in the current strata
case_day_strata <- which(strata == s & case > 0)
control_day_strata <- which(strata == s & case == 0)
# Initialize the control_day matrix for this strata
M <- length(case_day_strata)
N <- max_N
control_day_matrix <- matrix(0, nrow = M, ncol = N + 1)
# Populate the control_day matrix
for (i in seq_along(case_day_strata)) {
control_day_matrix[i, 1] <- case_day_strata[i]
control_day_matrix[i, 2:(length(control_day_strata) + 1)] <- control_day_strata
}
# Add this strata's control_day matrix to the list
control_day_list[[as.character(s)]] <- control_day_matrix
}
control_day <- do.call(rbind, control_day_list)
control_day
### My example:
example_data <- data.frame(case = c(0,1,0,0,0,1,0,0,1,0),
strata = c(1,1,1,2,2,2,3,3,3,3),
weight = c(0,1,0,0,0,5,0,0,2,0))
### we can find:
strata <- example_data$strata
case <- example_data$case
weight <- example_data$weight
case_day <- which(case > 0)
count <- weight[case_day]
### My example:
example_data <- data.frame(case = c(0,1,0,0,0,1,0,0,1,0),
strata = c(1,1,1,2,2,2,3,3,3,3),
weight = c(0,1,0,0,0,5,0,0,2,0))
### we can find:
strata <- example_data$strata
case <- example_data$case
weight <- example_data$weight
case_day <- which(case > 0)
count <- weight[case_day]
# Initialize a list to store the control_day for each strata
unique_strata <- unique(strata)
control_day_list <- list()
max_N <- max(sapply(unique_strata, function(s) sum(strata == s & case == 0)))
# Loop through each unique strata
for (s in unique_strata) {
# Get the indices for case days and control days in the current strata
case_day_strata <- which(strata == s & case > 0)
control_day_strata <- which(strata == s & case == 0)
# Initialize the control_day matrix for this strata
M <- length(case_day_strata)
N <- max_N
control_day_matrix <- matrix(0, nrow = M, ncol = N + 1)
# Populate the control_day matrix
for (i in seq_along(case_day_strata)) {
control_day_matrix[i, 1] <- case_day_strata[i]
control_day_matrix[i, 2:(length(control_day_strata) + 1)] <- control_day_strata
}
# Add this strata's control_day matrix to the list
control_day_list[[as.character(s)]] <- control_day_matrix
}
# Combine all strata matrices into one matrix
control_day <- do.call(rbind, control_day_list)
control_day
strata[control_day[1,],]
control_day[1,]
strata[control_day[1,]]
strata[control_day[2,]]
strata[control_day[3,]]
control_day_list
control_day
sd.prior <- list(prior = "exp", param = list(u = as.numeric(sd.prior), alpha = 0.5))
sd.prior <- list(prior = "exp", param = list(u = as.numeric(1), alpha = 0.5))
sd.prior
names(sd.prior)
"prior" !%in% names(sd.prior)
"prior" %in% names(sd.prior)
!"prior" %in% names(sd.prior)
names(1)
sd.prior
sd.prior$param <- list(u = sd.prior$param$u, alpha = sd.prior$param$alpha)
sd.prior
sd.prior <- list(prior = "exp", param = list(u = as.numeric(1)))
sd.prior$param <- list(u = sd.prior$param$u, alpha = sd.prior$param$alpha)
prior
sd.prior
sd.prior$prior
(sd.prior$prior != "exp" | sd.prior$prior != "Exp" | sd.prior$prior != "exponential" | sd.prior$prior != "Exponential")
USA <- read.delim("~/Desktop/mortality/USA/USA.txt")
View(USA)
USA
USA
range(USA$Year)
range(USA$Year.Code)
USA$Year.Code
unique(USA$Year.Code)
USA_2018_2023 <- read.delim("~/Desktop/mortality/USA/USA.txt")
USA_2018_2023$Year.Code
USA_2018_2023$Month.Code
USA_2018_2023$Population
USA_2018_2023$Ten.Year.Age.Groups
USA_2018_2023$Deaths
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths)
library(readxl)
library(dplyr)
library(tidyverse)
library(lubridate)
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths)
USA_2018_2023
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths) %>%
select(state, year, date, age, Deaths)
USA_2018_2023
USA_2018_2023
unique(USA_2018_2023$age)
USA_2018_2023 <- USA_2018_2023 %>%
mutate(
age = case_when(
age %in% c("25-34 years", "30-39 years", "35-44 years") ~ "25-45",
age %in% c("45-54 years", "50-59 years", "55-64 years") ~ "45-65",
age %in% c("65-74 years", "70-79 years", "75-84 years") ~ "65-85",
age %in% c("85+ years") ~ "Over 85",
age == "Not Stated" | age == "" ~ "Other",
TRUE ~ "Other"  # for unexpected categories, optional
)
)
USA_2018_2023
USA_2018_2023$state
unique(USA_2018_2023$state)
USA_2018_2023$state %>% filter(state == "")
USA_2018_2023 %>% filter(state == "")
USA_2018_2023 <- read.delim("~/Desktop/mortality/USA/USA.txt")
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths) %>%
select(state, year, date, age, Deaths)
USA_2018_2023$state
unique(USA_2018_2023$state)
USA_2018_2023 %>% filter(state == "")
!is.na(Deaths)
USA_2018_2023 <- USA_2018_2023 %>% filter(!is.na(Deaths))
USA_2018_2023
unique(USA_2018_2023$state)
options(warn=-1)
library(BayesGP)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>", fig.height=3, fig.width=5, margins=TRUE
)
knitr::knit_hooks$set(margins = function(before, options, envir) {
if (!before) return()
graphics::par(mar = c(1.5 + 0.9, 1.5 + 0.9, 0.2, 0.2), mgp = c(1.45, 0.45, 0), cex = 1.25, bty='n')
})
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
summary(mod)
mod$fixed_samp_indexes
unlist(mod$fixed_samp_indexes)
mod$samps[c(32,31), ]
mod$samps$samps[c(32,31), ]
dim(mod$samps$samps)
mod$boundary_samp_indexes
mod$fixed_samp_indexes
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>", fig.height=3, fig.width=5, margins=TRUE
)
knitr::knit_hooks$set(margins = function(before, options, envir) {
if (!before) return()
graphics::par(mar = c(1.5 + 0.9, 1.5 + 0.9, 0.2, 0.2), mgp = c(1.45, 0.45, 0), cex = 1.25, bty='n')
})
options(warn=-1)
library(BayesGP)
head(covid_canada)
fit_result <- model_fit(new_deaths ~ weekdays1 + weekdays2 + weekdays3 + weekdays4 + weekdays5 + weekdays6 +
f(smoothing_var = t, model = "IWP", order = 3, k = 100, sd.prior = list(prior = "exp", para = list(u = 0.02, alpha = 0.5))),
data = covid_canada, method = "aghq", family = "Poisson")
fit_result <- model_fit(new_deaths ~ weekdays1 + weekdays2 + weekdays3 + weekdays4 + weekdays5 + weekdays6 +
f(smoothing_var = t, model = "IWP", order = 3, k = 100, sd.prior = list(prior = "exp", param = list(u = 0.02, alpha = 0.5))),
data = covid_canada, method = "aghq", family = "Poisson")
head(covid_canada)
fit_result$fixed_samp_indexes
fit_result <- model_fit(new_deaths ~
f(smoothing_var = t, model = "IWP", order = 3, k = 100, sd.prior = list(prior = "exp", param = list(u = 0.02, alpha = 0.5))),
data = covid_canada, method = "aghq", family = "Poisson")
fit_result$fixed_samp_indexes
fit_result$boundary_samp_indexes
summary(fit_result)
fit_result <- model_fit(new_deaths ~
f(smoothing_var = t, model = "IWP", order = 2, k = 100, sd.prior = list(prior = "exp", param = list(u = 0.02, alpha = 0.5))),
data = covid_canada, method = "aghq", family = "Poisson")
summary(fit_result)
fit_result$fixed_samp_indexes
fit_result <- model_fit(new_deaths ~
f(smoothing_var = t, model = "IWP", order = 2, k = 100, sd.prior = list(prior = "exp", param = list(u = 0.02, alpha = 0.5))),
data = covid_canada, method = "aghq", family = "Gaussian")
summary(fit_result)
debugSource("~/Desktop/BayesGP/R/03_post_fit.R", echo=TRUE)
summary(fit_result)
cur_index
aghq_output
aghq_output
aghq_output[cur_index]
cat(paste(aghq_output[cur_index], collapse = "\n"))
as.matrix(aghq_summary$summarytable)
object$instances
length(object$instances)
object$instances[[1]]
theta_names
row.names(summary_table)
toString(family)
rep(1, 3)
fit_result <- model_fit(new_deaths ~
f(smoothing_var = t, model = "IWP", order = 2, k = 100, sd.prior = list(prior = "exp", param = list(u = 0.02, alpha = 0.5))),
data = covid_canada, method = "aghq", family = "Gaussian")
summary(fit_result)
source("~/Desktop/BayesGP/R/02_model_fit.R", echo=TRUE)
summary(fit_result)
source("~/Desktop/BayesGP/R/03_post_fit.R", echo=TRUE)
summary(fit_result)
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>", fig.height=3, fig.width=5, margins=TRUE
)
knitr::knit_hooks$set(margins = function(before, options, envir) {
if (!before) return()
graphics::par(mar = c(1.5 + 0.9, 1.5 + 0.9, 0.2, 0.2), mgp = c(1.45, 0.45, 0), cex = 1.25, bty='n')
})
options(warn=-1)
library(BayesGP)
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
summary(mod)
mod$fixed_samp_indexes
mod$random_samp_indexes
mod$boundary_samp_indexes
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
debugSource("~/Desktop/BayesGP/R/02_model_fit.R", echo=TRUE)
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
options(warn=-1)
library(BayesGP)
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
fixed_effects_names
control.fixed
control.fixed
w_count
cur_start
cur_end
cur_end
sum_col_ins
sum_col_ins
cur_start
cur_end
cur_end
cur_end
ncol(instance@X)
cur_start
cur_end
cur_coef_end
cur_coef_end
ncol(instance@B)
global_samp_indexes
global_effects_names
fixed_samp_index
cur_end
w_count
fixed_samp_indexes
fixed_effects_names
debugSource("~/Desktop/BayesGP/R/02_model_fit.R", echo=TRUE)
if(requireNamespace("casecrossover", quietly=TRUE)) {
data <- casecrossover::sim1data
data$exposure <- data$exposure
mod <- model_fit(formula = case ~ f(x = exposure,
model = "IWP",
order = 2, k = 30,
initial_location = median(data$exposure),
sd.prior = list(prior = "exp", param = list(u = 1, alpha = 0.5))),
family = "cc",
strata = "subject",
weight = NULL,
data = data,
method = "aghq")
}
