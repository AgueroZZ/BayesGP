local_poly
library(OSplines)
local_poly
global_poly
OSplines::local_poly_helper
library(OSplines)
library(tidyverse)
compute_post_fun
global_poly_helper
source("~/Documents/GitHub/OSplines/R/functions.R", echo=TRUE)
numeric(length = 10)
numeric(1,length = 10)
?numeric
numeric(length = 10) +1
?apply
parse_formula
parse_formula
parse_formula <- function(formula) {
components <- as.list(attributes(terms(formula))$ variables)
fixed_effects <- list()
rand_effects <- list()
# Index starts as 3 since index 1 represents "list" and
# index 2 represents the response variable
for (i in 3:length(components)) {
if (startsWith(toString(components[[i]]), "f,")) {
rand_effects[[length(rand_effects) + 1]] <- components[[i]]
} else {
fixed_effects[[length(fixed_effects) + 1]] <- components[[i]]
}
}
return(list(response = components[[2]], fixed_effects = fixed_effects, rand_effects = rand_effects))
}
parse_formula(y ~ x + f(s))
aaa <- parse_formula(y ~ x + f(s))
aaa$rand_effects
aaa$rand_effects[[1]]
aaa$rand_effects[[1]][1]
aaa$rand_effects[[1]][2]
aaa$rand_effects[[1]]
aaa$rand_effects[[1]]$s
aaa$rand_effects[[1]]$smoothing_Var
aaa$rand_effects[[1]]$smoothing_var
aaa <- parse_formula(y ~ x + f(smoothing_var = s))
aaa$rand_effects[[1]]
aaa$rand_effects[[1]]
aaa$rand_effects[[1]]$``
aaa$rand_effects[[1]]$smoothing_var
formula <- y~x + f(smoothing_var = s)
formula
components <- as.list(attributes(terms(formula))$ variables)
components
attributes(terms(formula))$ variables
attributes(terms(formula))$ variables
attributes(terms(formula))$ variables[1]
attributes(terms(formula))$ variables[2]
attributes(terms(formula))$ variables[3]
attributes(terms(formula))$ variables[4]
attributes(terms(formula))$ variables[4][1]
attributes(terms(formula))$ variables[4][[1]]
attributes(terms(formula))$ variables[4][[1]][1]
attributes(terms(formula))$ variables[4][[1]][2]
attributes(terms(formula))$ variables[4][[1]][3]
attributes(terms(formula))$ variables[4][[1]][2]
attributes(terms(formula))$ variables[4][[1]][[2]]
components
components[[4]]
components[[4]][[1]]
components[[4]][[2]]
components[[4]][[3]]
stop("")
stop("The covariate name must be specified as smoothing_var or x.")
formula <- y~x + f(smoothing_var = d)
formula[[1]]
formula[[2]]
formula[[3]]
parse_result <- parse_formula(formula)
parse_result
parse_result$rand_effects
parse_result$rand_effects[[1]]$smoothing_var
eval
formula <- y~x + f(smoothing_var = s, sd.prior = 2)
parse_result <- parse_formula(formula)
response_var <- parse_result$response
rand_effects <- parse_result$rand_effects
fixed_effects <- parse_result$fixed_effects
rand_effect = rand_effects[[1]]
rand_effect
eval(rand_effect$sd.prior)
rand_effect$sd.prior
formula <- y~x + f(smoothing_var = s, sd.prior = list(u = 1, alpha = 2))
rand_effects <- parse_result$rand_effects
parse_result <- parse_formula(formula)
rand_effects <- parse_result$rand_effects
rand_effect = rand_effects[[1]]
sd.prior <- eval(rand_effect$sd.prior)
sd.prior
length(rand_effects)
length(sd.prior)
sd.prior2 <- list(sd.prior$u)
sd.prior2
sd.prior2 <- list(u = sd.prior$u)
sd.prior2
as.numeric(sd.prior2)
sd.prior
sd.prior <- 1
sd.prior
if (length(sd.prior) == 1){
sd.prior <- list(prior = "exp", para = list(u = as.numeric(sd.prior), alpha = 0.5))
}
sd.prior
OSplines::covid_canada
OSplines::covid_canada[["t"]]
OSplines::covid_canada
mtcars
sort(mtcars, mpg)
sort(mtcars, by = mpg)
sort(mtcars, by = "mpg")
?sort
order(mtcars, by = "mpg")
order(mtcars, by = mpg)
newdata <- mtcars[order(mpg),]
newdata <- mtcars[order(mtcars$mpg),]
newdata
dplyr::arrange(mtcars, mpg)
sGPfit::compute_d_step_sGPsd
sGPfit::Compute_B_sB
sGPfit::Compute_B_sB
sGPfit::Compute_Q_sB
sGPfit::Compute_B_sB
debugSource("~/Documents/GitHub/OSplines/R/functions.R", echo=TRUE)
debugSource("~/Documents/GitHub/OSplines/R/functions.R", echo=TRUE)
k <- eval(rand_effect$k)
?nlminb()
nlminb
get_default_option_list_MCMC <- function(option_list = list()){
default_options <- list(chains = 1, cores = 1, init = "random", seed = 123)
for (name in required_names) {
if(! name %in% names(option_list)){
option_list[[name]] <- default_options[[name]]
}
}
option_list
}
get_default_option_list_MCMC(list(chains = 2))
get_default_option_list_MCMC <- function(option_list = list()){
default_options <- list(chains = 1, cores = 1, init = "random", seed = 123)
required_names <- names(default_options)
for (name in required_names) {
if(! name %in% names(option_list)){
option_list[[name]] <- default_options[[name]]
}
}
option_list
}
get_default_option_list_MCMC(list(chains = 2))
get_default_option_list_MCMC(list(chains = 3))
get_default_option_list_MCMC(list())
get_default_option_list_MCMC
get_default_option_list_MCMC
tmbstan::d
install.packages("tmbstan")
methods(class="stanfit").
methods(class="stanfit")
devtools::document()
warnings()
devtools::document()
warnings()
example_data <- data.frame(case = c(0,1,0,0,0,1,0,0,1,0),
strata = c(1,1,1,2,2,2,3,3,3,3),
weight = c(0,1,0,0,0,5,0,0,2,0))
example_data
case_day <- which(example_data$case > 0)
case_day
example_data[case_day,]
# Initialize a list to store the control_day for each strata
control_day_list <- list()
# Loop through unique strata
for (s in unique(example_data$strata)) {
# Subset data for each strata
strata_data <- example_data[example_data$strata == s, ]
# Identify case days within the strata
case_day_strata <- which(strata_data$case > 0)
# Identify control days within the strata
control_day_strata <- which(strata_data$case == 0)
# Create matrix to store results for this strata
N <- max(length(control_day_strata), 1)  # Ensure at least one column
M <- length(case_day_strata)
control_day_matrix <- matrix(0, nrow = M, ncol = N + 1)
for (i in 1:M) {
control_day_matrix[i, 1] <- case_day_strata[i]  # Case day itself as first column
control_day_matrix[i, 2:(N + 1)] <- control_day_strata  # Fill in the control days
}
# Add the matrix to the list
control_day_list[[as.character(s)]] <- control_day_matrix
}
control_day_list
max_N <- max(sapply(unique_strata, function(s) sum(strata == s & case == 0)))
unique_strata <- unique(strata)
### we can find:
strata <- example_data$strata
case <- example_data$case
case_day <- which(case > 0)
count <- weight[case_day]
strata <- example_data$strata
case <- example_data$case
weight <- example_data$weight
case_day <- which(case > 0)
count <- weight[case_day]
count
case_day
unique_strata <- unique(strata)
control_day_list <- list()
max_N <- max(sapply(unique_strata, function(s) sum(strata == s & case == 0)))
max_N
for (s in unique_strata) {
# Get the indices for case days and control days in the current strata
case_day_strata <- which(strata == s & case > 0)
control_day_strata <- which(strata == s & case == 0)
# Initialize the control_day matrix for this strata
M <- length(case_day_strata)
N <- max_N
control_day_matrix <- matrix(0, nrow = M, ncol = N + 1)
# Populate the control_day matrix
for (i in seq_along(case_day_strata)) {
control_day_matrix[i, 1] <- case_day_strata[i]
control_day_matrix[i, 2:(length(control_day_strata) + 1)] <- control_day_strata
}
# Add this strata's control_day matrix to the list
control_day_list[[as.character(s)]] <- control_day_matrix
}
control_day <- do.call(rbind, control_day_list)
control_day
### My example:
example_data <- data.frame(case = c(0,1,0,0,0,1,0,0,1,0),
strata = c(1,1,1,2,2,2,3,3,3,3),
weight = c(0,1,0,0,0,5,0,0,2,0))
### we can find:
strata <- example_data$strata
case <- example_data$case
weight <- example_data$weight
case_day <- which(case > 0)
count <- weight[case_day]
### My example:
example_data <- data.frame(case = c(0,1,0,0,0,1,0,0,1,0),
strata = c(1,1,1,2,2,2,3,3,3,3),
weight = c(0,1,0,0,0,5,0,0,2,0))
### we can find:
strata <- example_data$strata
case <- example_data$case
weight <- example_data$weight
case_day <- which(case > 0)
count <- weight[case_day]
# Initialize a list to store the control_day for each strata
unique_strata <- unique(strata)
control_day_list <- list()
max_N <- max(sapply(unique_strata, function(s) sum(strata == s & case == 0)))
# Loop through each unique strata
for (s in unique_strata) {
# Get the indices for case days and control days in the current strata
case_day_strata <- which(strata == s & case > 0)
control_day_strata <- which(strata == s & case == 0)
# Initialize the control_day matrix for this strata
M <- length(case_day_strata)
N <- max_N
control_day_matrix <- matrix(0, nrow = M, ncol = N + 1)
# Populate the control_day matrix
for (i in seq_along(case_day_strata)) {
control_day_matrix[i, 1] <- case_day_strata[i]
control_day_matrix[i, 2:(length(control_day_strata) + 1)] <- control_day_strata
}
# Add this strata's control_day matrix to the list
control_day_list[[as.character(s)]] <- control_day_matrix
}
# Combine all strata matrices into one matrix
control_day <- do.call(rbind, control_day_list)
control_day
strata[control_day[1,],]
control_day[1,]
strata[control_day[1,]]
strata[control_day[2,]]
strata[control_day[3,]]
control_day_list
control_day
sd.prior <- list(prior = "exp", param = list(u = as.numeric(sd.prior), alpha = 0.5))
sd.prior <- list(prior = "exp", param = list(u = as.numeric(1), alpha = 0.5))
sd.prior
names(sd.prior)
"prior" !%in% names(sd.prior)
"prior" %in% names(sd.prior)
!"prior" %in% names(sd.prior)
names(1)
sd.prior
sd.prior$param <- list(u = sd.prior$param$u, alpha = sd.prior$param$alpha)
sd.prior
sd.prior <- list(prior = "exp", param = list(u = as.numeric(1)))
sd.prior$param <- list(u = sd.prior$param$u, alpha = sd.prior$param$alpha)
prior
sd.prior
sd.prior$prior
(sd.prior$prior != "exp" | sd.prior$prior != "Exp" | sd.prior$prior != "exponential" | sd.prior$prior != "Exponential")
USA <- read.delim("~/Desktop/mortality/USA/USA.txt")
View(USA)
USA
USA
range(USA$Year)
range(USA$Year.Code)
USA$Year.Code
unique(USA$Year.Code)
USA_2018_2023 <- read.delim("~/Desktop/mortality/USA/USA.txt")
USA_2018_2023$Year.Code
USA_2018_2023$Month.Code
USA_2018_2023$Population
USA_2018_2023$Ten.Year.Age.Groups
USA_2018_2023$Deaths
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths)
library(readxl)
library(dplyr)
library(tidyverse)
library(lubridate)
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths)
USA_2018_2023
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths) %>%
select(state, year, date, age, Deaths)
USA_2018_2023
USA_2018_2023
unique(USA_2018_2023$age)
USA_2018_2023 <- USA_2018_2023 %>%
mutate(
age = case_when(
age %in% c("25-34 years", "30-39 years", "35-44 years") ~ "25-45",
age %in% c("45-54 years", "50-59 years", "55-64 years") ~ "45-65",
age %in% c("65-74 years", "70-79 years", "75-84 years") ~ "65-85",
age %in% c("85+ years") ~ "Over 85",
age == "Not Stated" | age == "" ~ "Other",
TRUE ~ "Other"  # for unexpected categories, optional
)
)
USA_2018_2023
USA_2018_2023$state
unique(USA_2018_2023$state)
USA_2018_2023$state %>% filter(state == "")
USA_2018_2023 %>% filter(state == "")
USA_2018_2023 <- read.delim("~/Desktop/mortality/USA/USA.txt")
USA_2018_2023 <- USA_2018_2023 %>% mutate(state = Residence.State, year = Year.Code,
date = Month.Code, age = Ten.Year.Age.Groups,
Deaths = Deaths) %>%
select(state, year, date, age, Deaths)
USA_2018_2023$state
unique(USA_2018_2023$state)
USA_2018_2023 %>% filter(state == "")
!is.na(Deaths)
USA_2018_2023 <- USA_2018_2023 %>% filter(!is.na(Deaths))
USA_2018_2023
unique(USA_2018_2023$state)
